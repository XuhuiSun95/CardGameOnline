/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef cg_TYPES_H
#define cg_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




struct Method {
  enum type {
    GET = 1,
    POST = 2
  };
};

extern const std::map<int, const char*> _Method_VALUES_TO_NAMES;

class Table;

class Card;

class TRM_OBJ;

typedef struct _Table__isset {
  _Table__isset() : table_id(false), slot(false) {}
  bool table_id :1;
  bool slot :1;
} _Table__isset;

class Table {
 public:

  Table(const Table&);
  Table& operator=(const Table&);
  Table() : table_id(0) {
  }

  virtual ~Table() throw();
  int32_t table_id;
  std::vector<bool>  slot;

  _Table__isset __isset;

  void __set_table_id(const int32_t val);

  void __set_slot(const std::vector<bool> & val);

  bool operator == (const Table & rhs) const
  {
    if (!(table_id == rhs.table_id))
      return false;
    if (!(slot == rhs.slot))
      return false;
    return true;
  }
  bool operator != (const Table &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Table & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Table &a, Table &b);

inline std::ostream& operator<<(std::ostream& out, const Table& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Card__isset {
  _Card__isset() : type(false), value(false) {}
  bool type :1;
  bool value :1;
} _Card__isset;

class Card {
 public:

  Card(const Card&);
  Card& operator=(const Card&);
  Card() : type(), value() {
  }

  virtual ~Card() throw();
  std::string type;
  std::string value;

  _Card__isset __isset;

  void __set_type(const std::string& val);

  void __set_value(const std::string& val);

  bool operator == (const Card & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Card &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Card & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Card &a, Card &b);

inline std::ostream& operator<<(std::ostream& out, const Card& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TRM_OBJ__isset {
  _TRM_OBJ__isset() : player_id(false), played_cards(false) {}
  bool player_id :1;
  bool played_cards :1;
} _TRM_OBJ__isset;

class TRM_OBJ {
 public:

  TRM_OBJ(const TRM_OBJ&);
  TRM_OBJ& operator=(const TRM_OBJ&);
  TRM_OBJ() : player_id(0) {
  }

  virtual ~TRM_OBJ() throw();
  int32_t player_id;
  std::vector<Card>  played_cards;

  _TRM_OBJ__isset __isset;

  void __set_player_id(const int32_t val);

  void __set_played_cards(const std::vector<Card> & val);

  bool operator == (const TRM_OBJ & rhs) const
  {
    if (!(player_id == rhs.player_id))
      return false;
    if (!(played_cards == rhs.played_cards))
      return false;
    return true;
  }
  bool operator != (const TRM_OBJ &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRM_OBJ & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRM_OBJ &a, TRM_OBJ &b);

inline std::ostream& operator<<(std::ostream& out, const TRM_OBJ& obj)
{
  obj.printTo(out);
  return out;
}



#endif
